// customer-auth-service/index.js

const express = require("express");
const mysql = require("mysql2");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
const cors = require("cors");
// ðŸ’¡ We don't need 'url' here because mysql2 can often parse the full URL directly.

const app = express();
app.use(cors());
app.use(express.json());

// --------------------------------------------------
// Configuration
// --------------------------------------------------
const JWT_SECRET = process.env.JWT_SECRET || "your_customer_secret_key";

// --------------------------------------------------
// âœ… DATABASE CONNECTION: USE RAILWAY ENVIRONMENT VARIABLE
// --------------------------------------------------

// 1. Get the single connection URL from Railway
const dbUrl = process.env.MYSQL_URL; 

if (!dbUrl) {
    console.error("âŒ FATAL ERROR: MYSQL_URL environment variable is not set. Exiting.");
    process.exit(1); 
}

// 2. The mysql2 library can often handle the full connection URL string directly.
// This is much cleaner than manually parsing host, user, and password.
// The database name used by this service ('customer_auth_db') MUST be the one 
// included in the MYSQL_URL string generated by Railway, or we will need to parse the URL.

// Since the `customer_auth_db` is specified in your old config, 
// let's assume the full URL is sufficient, or you need to re-add the specific DB name
// if the Railway generated URL points to a default database name like 'railway'.

// OPTION: Simple Connection using the full URL (Preferred)
const db = mysql.createPool(dbUrl).promise(); 

// --------------------------------------------------
// Connection Check
// --------------------------------------------------
db.getConnection()
Â  Â  .then(() => console.log("âœ… Customer Auth Service: MySQL connected successfully"))
Â  Â  .catch((err) => console.error("âŒ MySQL connection error:", err.message));

// --------------------------------------------------
// Helper Functions
// --------------------------------------------------
function validatePassword(password) {
Â  Â  const rules = [
Â  Â  Â  Â  { regex: /.{8,}/, message: "Password must be at least 8 characters long" },
Â  Â  Â  Â  { regex: /[A-Z]/, message: "Password must contain at least one uppercase letter" },
Â  Â  Â  Â  { regex: /[a-z]/, message: "Password must contain at least one lowercase letter" },
Â  Â  Â  Â  { regex: /[0-9]/, message: "Password must contain at least one number" },
Â  Â  Â  Â  { regex: /[^A-Za-z0-9]/, message: "Password must contain at least one special character" },
Â  Â  ];
Â  Â  for (const rule of rules) {
Â  Â  Â  Â  if (!rule.regex.test(password)) return rule.message;
Â  Â  }
Â  Â  return null;
}

// Simple email validation
function isValidEmail(email) {
Â  Â  return /\S+@\S+\.\S+/.test(email);
}

// --------------------------------------------------
// Routes
// --------------------------------------------------

// Registration
app.post("/register", async (req, res) => {
Â  Â  // UPDATED: Destructure the new gmail field
Â  Â  const { username, password, acceptPolicy, firstName, lastName, middleInitial, gmail } = req.body;
Â  Â Â 
Â  Â  // UPDATED: Include gmail in the required fields check
Â  Â  if (!username || !password || !firstName || !lastName || !gmail) {
Â  Â  Â  Â  return res
Â  Â  Â  Â  Â  Â  .status(400)
Â  Â  Â  Â  Â  Â  .json({ message: "Username, password, first name, last name, and email are required" });
Â  Â  }
Â  Â Â 
Â  Â  // NEW: Validate email format
Â  Â  if (!isValidEmail(gmail)) {
Â  Â  Â  Â  return res.status(400).json({ message: "Invalid email format." });
Â  Â  }

Â  Â  if (!acceptPolicy) {
Â  Â  Â  Â  return res
Â  Â  Â  Â  Â  Â  .status(400)
Â  Â  Â  Â  Â  Â  .json({ message: "You must accept the Terms & Privacy Policy" });
Â  Â  }
Â  Â  const passwordError = validatePassword(password);
Â  Â  if (passwordError) return res.status(400).json({ message: passwordError });
Â  Â  try {
Â  Â  Â  Â  const [existing] = await db.execute(
Â  Â  Â  Â  Â  Â  // Check for both existing username AND existing email
Â  Â  Â  Â  Â  Â  "SELECT id, username, gmail FROM customers WHERE username = ? OR gmail = ?",
Â  Â  Â  Â  Â  Â  [username, gmail]
Â  Â  Â  Â  );
Â  Â  Â  Â  if (existing.length) {
Â  Â  Â  Â  Â  Â  const userExists = existing.some(row => row.username === username);
Â  Â  Â  Â  Â  Â  const emailExists = existing.some(row => row.gmail === gmail);
Â  Â  Â  Â  Â  Â  if (userExists) return res.status(409).json({ message: "Username already taken" });
Â  Â  Â  Â  Â  Â  if (emailExists) return res.status(409).json({ message: "Email address already registered" });
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  const hashedPassword = await bcrypt.hash(password, 10);
Â  Â  Â  Â  const policyValue = acceptPolicy ? 1 : 0;
Â  Â Â 
Â  Â  Â  Â  // UPDATED: Insert the new gmail column and value
Â  Â  Â  Â  await db.execute(
Â  Â  Â  Â  Â  Â  `INSERT INTO customers
Â  Â  Â  Â  Â  Â  Â (first_name, last_name, middle_initial, username, password_hash, gmail, policy_accepted)
Â  Â  Â  Â  Â  Â  Â VALUES (?, ?, ?, ?, ?, ?, ?)`,
Â  Â  Â  Â  Â  Â  [firstName, lastName, middleInitial || "", username, hashedPassword, gmail, policyValue]
Â  Â  Â  Â  );
Â  Â  Â  Â  res.status(201).json({ message: "Customer registered successfully" });
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error("Registration error:", err);
Â  Â  Â  Â  res.status(500).json({ message: "Internal server error during registration" });
Â  Â  }
});

// Login
app.post("/login", async (req, res) => {
Â  Â  const { username, password } = req.body;
Â  Â  if (!username || !password) {
Â  Â  Â  Â  return res.status(400).json({ message: "Username and password are required" });
Â  Â  }
Â  Â  try {
Â  Â  Â  Â  // NOTE: Fetching password_hash is enough for login
Â  Â  Â  Â  const [rows] = await db.execute(
Â  Â  Â  Â  Â  Â  "SELECT id, username, password_hash FROM customers WHERE username = ?",
Â  Â  Â  Â  Â  Â  [username]
Â  Â  Â  Â  );
Â  Â  Â  Â  if (!rows.length) {
Â  Â  Â  Â  Â  Â  return res.status(401).json({ message: "Invalid username or password" });
Â  Â  Â  Â  }
Â  Â  Â  Â  const customer = rows[0];
Â  Â  Â  Â  const isValid = await bcrypt.compare(password, customer.password_hash);
Â  Â  Â  Â  if (!isValid) {
Â  Â  Â  Â  Â  Â  return res.status(401).json({ message: "Invalid username or password" });
Â  Â  Â  Â  }
Â  Â  Â  Â  const token = jwt.sign(
Â  Â  Â  Â  Â  Â  { id: customer.id, username: customer.username, type: "customer" },
Â  Â  Â  Â  Â  Â  JWT_SECRET,
Â  Â  Â  Â  Â  Â  { expiresIn: "1h" }
Â  Â  Â  Â  );
Â  Â  Â  Â  res.json({ message: "Login successful", token });
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error("Login error:", err);
Â  Â  Â  Â  res.status(500).json({ message: "Internal server error" });
Â  Â  }
});

// Daily User Registration Analytics
app.get("/analytics/users-daily", async (_req, res) => {
Â  Â  try {
Â  Â  Â  Â  const [rows] = await db.execute(`
Â  Â  Â  Â  Â  Â  SELECT DATE(created_at) AS date, COUNT(id) AS count
Â  Â  Â  Â  Â  Â  FROM customers
Â  Â  Â  Â  Â  Â  GROUP BY DATE(created_at)
Â  Â  Â  Â  Â  Â  ORDER BY date ASC
Â  Â  Â  Â  Â  Â  LIMIT 30
Â  Â  Â  Â  `);
Â  Â  Â  Â  res.json(rows);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error("Error fetching daily user registrations:", err);
Â  Â  Â  Â  res.status(500).json({ error: "Failed to fetch daily user registrations" });
Â  Â  }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Endpoint to get Customer Name and Email for Order Service
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.get('/customer/:customerId/details', async (req, res) => {
Â  Â  const { customerId } = req.params;
Â  Â Â 
Â  Â  try {
Â  Â  Â  Â  const [rows] = await db.execute(
Â  Â  Â  Â  Â  Â  `SELECT first_name, last_name, gmailÂ 
Â  Â  Â  Â  Â  Â  Â FROM customersÂ 
Â  Â  Â  Â  Â  Â  Â WHERE id = ?`,
Â  Â  Â  Â  Â  Â  [customerId]
Â  Â  Â  Â  );

Â  Â  Â  Â  if (rows.length === 0) {
Â  Â  Â  Â  Â  Â  return res.status(404).json({ message: 'Customer not found' });
Â  Â  Â  Â  }

Â  Â  Â  Â  const customer = rows[0];

Â  Â  Â  Â  // Construct the required response format for the Orders Service
Â  Â  Â  Â  const customerDetails = {
Â  Â  Â  Â  Â  Â  customer_name: `${customer.first_name} ${customer.last_name}`,
Â  Â  Â  Â  Â  Â  customer_email: customer.gmail
Â  Â  Â  Â  };

Â  Â  Â  Â  res.json(customerDetails);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error fetching customer details for Order Service:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Internal server error fetching customer details.' });
Â  Â  }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Customer Address Endpoints
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Get all addresses for a specific customer
app.get('/customer/:customerId/addresses', async (req, res) => {
Â  Â  const { customerId } = req.params;
Â  Â  try {
Â  Â  Â  Â  const [addresses] = await db.execute(
Â  Â  Â  Â  Â  Â  'SELECT id, full_name, full_address, contact_number FROM customer_addresses WHERE customer_id = ? ORDER BY id DESC',
Â  Â  Â  Â  Â  Â  [customerId]
Â  Â  Â  Â  );
Â  Â  Â  Â  res.json(addresses);
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error fetching addresses:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Failed to fetch addresses' });
Â  Â  }
});

// Save a new address for a customer
app.post('/customer/:customerId/addresses', async (req, res) => {
Â  Â  const { customerId } = req.params;
Â  Â  const { fullName, fullAddress, contact } = req.body;
Â  Â  try {
Â  Â  Â  Â  const [result] = await db.execute(
Â  Â  Â  Â  Â  Â  'INSERT INTO customer_addresses (customer_id, full_name, full_address, contact_number) VALUES (?, ?, ?, ?)',
Â  Â  Â  Â  Â  Â  [customerId, fullName, fullAddress, contact]
Â  Â  Â  Â  );
Â  Â  Â  Â  res.status(201).json({ id: result.insertId, message: 'Address saved successfully' });
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error saving address:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Failed to save address' });
Â  Â  }
});

// Delete an address
app.delete('/customer/addresses/:addressId', async (req, res) => {
Â  Â  const { addressId } = req.params;
Â  Â  try {
Â  Â  Â  Â  await db.execute('DELETE FROM customer_addresses WHERE id = ?', [addressId]);
Â  Â  Â  Â  res.status(200).json({ message: 'Address deleted successfully' });
Â  Â  } catch (err) {
Â  Â  Â  Â  console.error('Error deleting address:', err);
Â  Â  Â  Â  res.status(500).json({ error: 'Failed to delete address' });
Â  Â  }
});

// --------------------------------------------------
// Start Server
// --------------------------------------------------
app.listen(5004, () => {
Â  Â  console.log("Customer Auth Service running on port 5004");
});
